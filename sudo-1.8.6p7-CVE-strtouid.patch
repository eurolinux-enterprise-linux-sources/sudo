diff -up ./plugins/sudoers/sudoers.c.CVE-strtouid ./plugins/sudoers/sudoers.c
--- ./plugins/sudoers/sudoers.c.CVE-strtouid	2019-10-22 10:13:06.295882830 +0200
+++ ./plugins/sudoers/sudoers.c	2019-10-22 10:45:12.583351449 +0200
@@ -95,8 +95,8 @@
 static void init_vars(char * const *);
 static int set_cmnd(void);
 static void set_loginclass(struct passwd *);
-static void set_runaspw(const char *);
-static void set_runasgr(const char *);
+static bool set_runaspw(const char *);
+static bool set_runasgr(const char *);
 static int cb_runas_default(const char *);
 static int sudoers_policy_version(int verbose);
 static int deserialize_info(char * const args[], char * const settings[],
@@ -233,11 +233,14 @@ sudoers_policy_open(unsigned int version
      * defer setting runas_pw so the match routines know to ignore it.
      */
     if (runas_group != NULL) {
-	set_runasgr(runas_group);
+        if (!set_runasgr(runas_group))
+	    debug_return_bool(false);
 	if (runas_user != NULL)
-	    set_runaspw(runas_user);
+	    if (!set_runaspw(runas_user))
+	      debug_return_bool(false);
     } else
-	set_runaspw(runas_user ? runas_user : def_runas_default);
+      if (!set_runaspw(runas_user ? runas_user : def_runas_default))
+	  debug_return_bool(false);
 
     if (!update_defaults(SETDEF_RUNAS))
 	log_error(NO_STDERR, _("problem with defaults entries"));
@@ -1125,60 +1128,164 @@ set_fqdn(void)
     debug_return;
 }
 
+
 /*
- * Get passwd entry for the user we are going to run commands as
- * and store it in runas_pw.  By default, commands run as "root".
+ * Make sure that the ID ends with a valid separator char.
  */
-static void
+static bool
+valid_separator(const char *p, const char *ep, const char *sep)
+{
+    bool valid = false;
+    debug_decl(valid_separator, SUDO_DEBUG_UTIL)
+
+    if (ep != p) {
+	/* check for valid separator (including '\0') */
+	if (sep == NULL)
+	    sep = "";
+	do {
+	    if (*ep == *sep)
+		valid = true;
+	} while (*sep++ != '\0');
+    }
+    debug_return_int(valid);
+}
+
+/*
+ * Parse a uid/gid in string form.
+ * If sep is non-NULL, it contains valid separator characters (e.g. comma, space)
+ * If endp is non-NULL it is set to the next char after the ID.
+ * On success, returns the parsed ID and clears errstr.
+ * On error, returns 0 and sets errstr.
+ */
+static id_t
+sudo_strtoid(const char *p, const char *sep, char **endp, const char **errstr)
+{
+    char *ep;
+    id_t ret = 0;
+    debug_decl(sudo_strtoid, SUDO_DEBUG_UTIL)
+
+    /* skip leading space so we can pick up the sign, if any */
+    while (isspace((unsigned char)*p))
+	p++;
+
+    errno = 0;
+    if (*p == '-') {
+	long lval = strtol(p, &ep, 10);
+	if ((errno == ERANGE && lval == LONG_MAX) || lval > INT_MAX) {
+	    errno = ERANGE;
+	    if (errstr != NULL)
+		*errstr = N_("value too large");
+	    goto done;
+	}
+	if ((errno == ERANGE && lval == LONG_MIN) || lval < INT_MIN) {
+	    errno = ERANGE;
+	    if (errstr != NULL)
+		*errstr = N_("value too small");
+	    goto done;
+	}
+
+	/* Disallow id -1, which means "no change". */
+	if (!valid_separator(p, ep, sep) || lval == -1) {
+	    if (errstr != NULL)
+		*errstr = N_("invalid value");
+	    errno = EINVAL;
+	    goto done;
+	}
+	ret = (id_t)lval;
+    } else {
+	unsigned long ulval = strtoul(p, &ep, 10);
+	if ((errno == ERANGE && ulval == ULONG_MAX) || ulval > UINT_MAX) {
+	    errno = ERANGE;
+	    if (errstr != NULL)
+		*errstr = N_("value too large");
+	    goto done;
+	}
+
+	/* Disallow id -1, which means "no change". */
+	if (!valid_separator(p, ep, sep) || ulval == UINT_MAX) {
+	    if (errstr != NULL)
+		*errstr = N_("invalid value");
+	    errno = EINVAL;
+	    goto done;
+	}
+	ret = (id_t)ulval;
+    }
+    if (errstr != NULL)
+	*errstr = NULL;
+    if (endp != NULL)
+	*endp = ep;
+done:
+    debug_return_int(ret);
+}
+
+
+static bool
 set_runaspw(const char *user)
 {
+    struct passwd *pw = NULL;
     debug_decl(set_runaspw, SUDO_DEBUG_PLUGIN)
 
-    if (runas_pw != NULL)
-	sudo_pw_delref(runas_pw);
     if (*user == '#') {
-	if ((runas_pw = sudo_getpwuid(atoi(user + 1))) == NULL)
-	    runas_pw = sudo_fakepwnam(user, runas_gr ? runas_gr->gr_gid : 0);
-    } else {
-	if ((runas_pw = sudo_getpwnam(user)) == NULL)
-	    log_fatal(NO_MAIL|MSG_ONLY, _("unknown user: %s"), user);
+	const char *errstr;
+	uid_t uid = sudo_strtoid(user + 1, NULL, NULL, &errstr);
+	if (errstr == NULL) {
+	    if ((pw = sudo_getpwuid(uid)) == NULL)
+		pw = sudo_fakepwnam(user, user_gid);
+	}
     }
-    debug_return;
+    if (pw == NULL) {
+	if ((pw = sudo_getpwnam(user)) == NULL) {
+	    debug_return_int(0);
+	}
+    }
+    if (runas_pw != NULL)
+	sudo_pw_delref(runas_pw);
+    runas_pw = pw;
+    debug_return_int(1);
 }
 
 /*
  * Get group entry for the group we are going to run commands as
  * and store it in runas_gr.
  */
-static void
+static bool
 set_runasgr(const char *group)
 {
+    struct group *gr = NULL;
     debug_decl(set_runasgr, SUDO_DEBUG_PLUGIN)
 
-    if (runas_gr != NULL)
-	sudo_gr_delref(runas_gr);
     if (*group == '#') {
-	if ((runas_gr = sudo_getgrgid(atoi(group + 1))) == NULL)
-	    runas_gr = sudo_fakegrnam(group);
-    } else {
-	if ((runas_gr = sudo_getgrnam(group)) == NULL)
-	    log_fatal(NO_MAIL|MSG_ONLY, _("unknown group: %s"), group);
+	const char *errstr;
+	gid_t gid = sudo_strtoid(group + 1, NULL, NULL, &errstr);
+	if (errstr == NULL) {
+	    if ((gr = sudo_getgrgid(gid)) == NULL)
+		gr = sudo_fakegrnam(group);
+	}
     }
-    debug_return;
+    if (gr == NULL) {
+	if ((gr = sudo_getgrnam(group)) == NULL) {
+	    debug_return_int(0);
+	}
+    }
+    if (runas_gr != NULL)
+	sudo_gr_delref(runas_gr);
+    runas_gr = gr;
+    debug_return_int(1);
 }
 
-/*
- * Callback for runas_default sudoers setting.
- */
+
 static int
 cb_runas_default(const char *user)
 {
+  debug_decl(cb_runas_default, SUDO_DEBUG_PLUGIN)
+
     /* Only reset runaspw if user didn't specify one. */
     if (!runas_user && !runas_group)
-	set_runaspw(user);
-    return true;
+      debug_return_int(set_runaspw(user));
+  debug_return_int(1);
 }
 
+
 /*
  * Cleanup hook for error()/errorx()
  */
